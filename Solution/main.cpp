#include "SequenceGenerator.h"
#include <iostream>
#include <vector>
#include "ComplexityToDebruijn.h"
#include <fstream>
#include <chrono>
#include <omp.h>
using namespace std::chrono;
using namespace std;

int main(){
    omp_set_num_threads(24);
    cout << "Starting..." << endl;
    /*auto start = high_resolution_clock::now();
    SequenceGenerator se(17);
    auto d = se.getSequences();
    cout << se.getNumOfSeq() << endl;
    for (int i = 0; i < d.size(); ++i) {
        cout << d[i] << endl;
    }
    auto end = high_resolution_clock::now();
    auto duration= duration_cast<seconds>(end - start);
    cout << duration.count() << " seconds" << endl;
    return 0;*/
    int order = 7;
    for(int c = 84; c <= 84; c++){
        auto start = high_resolution_clock::now();

        int complexity = c;
        ll total = 0;
        ComplexityToDebruijn C(complexity,order);
        //SequenceGenerator seq(complexity - pow(2,order - 1));
        //auto s = seq.getSequences();
        /*TODO:
        * automate the complexity choosing
        * remove rotations from sub sequences
        */
        C.compute();
        auto res = C.getSubseqToDebruijn();
        auto to_print = C.getUpTo1000();
        std::ofstream out("order_"+ to_string(order)+"_complexity_"+ to_string(c) +"_omp.txt");
        std::streambuf *coutbuf = std::cout.rdbuf(); //save old buf
        std::cout.rdbuf(out.rdbuf()); //redirect std::cout to out.txt!
        cout << "For order "<< order << " complexity "<< complexity<< ":" << endl;
        for (int i = 0; i < res.size(); ++i) {
            auto x = res[i];
            cout <<"Debruijn Sequences generated by the sub sequence "<< x.first << " : " << endl;
            for (const auto& str : to_print[i]) {
                cout << str << endl;
            }
            cout << "the number of Debruijn sequences: "   << x.second << endl << endl;
            total+=x.second;
        }

        cout << "number of subsequences with complexity " << complexity - pow(2,order - 1)<< " is: " << res.size() << endl;
        cout << "total number of sequences of complexity " << c << " is: " << total << endl;

        auto end = high_resolution_clock::now();
        auto duration= duration_cast<seconds>(end - start);

        if(duration.count() < 1)
            cout << "overall execution time is " << duration_cast<milliseconds>(end - start).count() << " milliseconds" << endl;
        else if(duration.count() > 60 && duration.count() < 3600)
            cout << "overall execution time is " << duration_cast<minutes>(end - start).count() << " minutes" << endl;
        else if(duration.count() >= 3600)
            cout << "overall execution time is " << duration_cast<hours>(end - start).count() << " hours, " << duration_cast<minutes>(end - start).count() % 60 << " minutes" << endl;
        else
            cout << "overall execution time is " << duration.count() << " seconds" << endl;

        /*************************************** reset cout buff*****************************************************/
        std::cout.rdbuf(coutbuf); //reset to standard output again
        cout << "total number of sequences of complexity " << c << " is: " << total << endl;

        if(duration.count() < 1)
            cout << "overall execution time is " << duration_cast<milliseconds>(end - start).count() << " milliseconds" << endl;
        else if(duration.count() > 60 && duration.count() < 3600)
            cout << "overall execution time is " << duration_cast<minutes>(end - start).count() << " minutes" << endl;
        else if(duration.count() >= 3600)
            cout << "overall execution time is " << duration_cast<hours>(end - start).count() << " hours, " << duration_cast<minutes>(end - start).count() % 60 << " minutes" << endl;
        else
            cout << "overall execution time is " << duration.count() << " seconds" << endl;

        cout <<  endl;
    }
    cout << "Done with all complexities!!!" << endl;
}